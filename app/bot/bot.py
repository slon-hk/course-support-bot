import os
import logging
import asyncio
from aiogram import Bot, Dispatcher, types
from aiogram.filters import Command
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from app.models import Course, db, User
from flask import Flask
import requests
from app.services.vector_db import VectorDB
from app.ai import answer_question

logger = logging.getLogger(__name__)

API_BASE_URL = "http://127.0.0.1:5000/api/telegram"  # –ê–¥—Ä–µ—Å –≤–∞—à–µ–≥–æ Flask API

class CourseBot:
    def __init__(self, app: Flask):
        if not app:
            raise ValueError("Flask application must be provided")

        self.app = app
        self.token = os.environ.get('TELEGRAM_BOT_TOKEN')
        if not self.token:
            raise ValueError("TELEGRAM_BOT_TOKEN not found in environment variables")

        logger.info("Initializing Telegram bot...")
        self.bot = Bot(token=self.token)
        self.dp = Dispatcher()
        self.user_states = {}
        self._register_handlers()
        logger.info("Bot handlers registered successfully")

        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è VectorDB
        self.vector_db_path = os.path.join(os.getcwd(), "app", "data")
        logger.info(f"Vector DB path: {self.vector_db_path}")

    def _register_handlers(self):
        """–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ –∫–æ–º–∞–Ω–¥"""
        try:
            self.dp.message.register(self.start_handler, Command("start"))
            self.dp.message.register(self.list_courses_handler, Command("courses"))
            self.dp.message.register(self.help_handler, Command("help"))
            self.dp.message.register(self.ask_handler, Command("ask"))  # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /ask
            self.dp.message.register(self.process_question)  # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –≤–æ–ø—Ä–æ—Å–æ–≤ –ø–æ—Å–ª–µ –≤—ã–±–æ—Ä–∞ –∫—É—Ä—Å–∞
            self.dp.callback_query.register(
                self.course_callback_handler,
                lambda c: c.data.startswith('course_')
            )
            self.dp.callback_query.register(
                self.materials_callback_handler,
                lambda c: c.data.startswith('materials_')
            )
            self.dp.callback_query.register(
                self.ask_course_callback_handler,
                lambda c: c.data.startswith('ask_course_')
            )
            self.dp.callback_query.register(
                self.after_question_callback_handler,
                lambda c: c.data in ['end_dialog']
            )
        except Exception as e:
            logger.error(f"Error registering handlers: {e}", exc_info=True)
            raise

    async def start_handler(self, message: types.Message):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start"""
        try:
            logger.info(f"Start command received from user {message.from_user.id}")
            welcome_text = (
                "üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –±–æ—Ç —Å–∏—Å—Ç–µ–º—ã —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫—É—Ä—Å–∞–º–∏!\n\n"
                "–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n"
                "/courses - –ü—Ä–æ—Å–º–æ—Ç—Ä —Å–ø–∏—Å–∫–∞ –∫—É—Ä—Å–æ–≤\n"
                "/ask - –ó–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å –ø–æ –º–∞—Ç–µ—Ä–∏–∞–ª–∞–º –∫—É—Ä—Å–∞\n"
                "/help - –ü–æ–º–æ—â—å –∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è"
            )
            await self.bot.send_message(chat_id=message.chat.id, text=welcome_text)
        except Exception as e:
            logger.error(f"Error in start handler: {e}", exc_info=True)
            await self.bot.send_message(chat_id=message.chat.id, text="‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∫–æ–º–∞–Ω–¥—ã")

    async def ask_handler(self, message: types.Message):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /ask - –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –∫—É—Ä—Å–æ–≤ –¥–ª—è –≤—ã–±–æ—Ä–∞"""
        try:
            with self.app.app_context():
                courses = Course.query.all()
                if not courses:
                    await message.answer("üìö –ù–∞ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫—É—Ä—Å–æ–≤")
                    return

                keyboard = InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(
                        text=f"üìò {course.title}",
                        callback_data=f"ask_course_{course.id}"
                    )]
                    for course in courses
                ])

                await message.answer("üìö –í—ã–±–µ—Ä–∏—Ç–µ –∫—É—Ä—Å, –ø–æ –∫–æ—Ç–æ—Ä–æ–º—É —Ö–æ—Ç–∏—Ç–µ –∑–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å:", reply_markup=keyboard)
                logger.info(f"Ask command processed for user {message.from_user.id}")

        except Exception as e:
            logger.error(f"Error in ask handler: {e}", exc_info=True)
            await message.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ –∫—É—Ä—Å–æ–≤")

    async def list_courses_handler(self, message: types.Message):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /courses"""
        try:
            with self.app.app_context():
                courses = Course.query.all()
                if not courses:
                    await message.answer("üìö –ù–∞ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫—É—Ä—Å–æ–≤")
                    return

                keyboard = InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(
                        text=f"üìò {course.title}",
                        callback_data=f"course_{course.id}"
                    )]
                    for course in courses
                ])

                await message.answer("üìö –î–æ—Å—Ç—É–ø–Ω—ã–µ –∫—É—Ä—Å—ã:", reply_markup=keyboard)
                logger.info(f"Courses listed for user {message.from_user.id}")
        except Exception as e:
            logger.error(f"Error in list courses handler: {e}")
            await message.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ –∫—É—Ä—Å–æ–≤")

    async def course_callback_handler(self, callback: types.CallbackQuery):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—ã–±–æ—Ä–∞ –∫—É—Ä—Å–∞"""
        try:
            course_id = int(callback.data.split('_')[1])
            with self.app.app_context():
                course = Course.query.get(course_id)
                if not course:
                    await callback.answer("‚ùå –ö—É—Ä—Å –Ω–µ –Ω–∞–π–¥–µ–Ω")
                    return

                text = f"üìò {course.title}\n\n{course.description or '–û–ø–∏—Å–∞–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç'}"
                keyboard = InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(
                        text="üìö –ú–∞—Ç–µ—Ä–∏–∞–ª—ã –∫—É—Ä—Å–∞",
                        callback_data=f"materials_{course_id}"
                    )]
                ])

                await callback.message.edit_text(text, reply_markup=keyboard)
                await callback.answer()
        except Exception as e:
            logger.error(f"Error in course callback handler: {e}")
            await callback.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞")

    async def materials_callback_handler(self, callback: types.CallbackQuery):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤ –∫—É—Ä—Å–∞"""
        try:
            course_id = int(callback.data.split('_')[1])
            with self.app.app_context():
                course = Course.query.get(course_id)
                if not course:
                    await callback.answer("‚ùå –ö—É—Ä—Å –Ω–µ –Ω–∞–π–¥–µ–Ω")
                    return

                materials = course.materials
                if not materials:
                    await callback.message.edit_text("–í —ç—Ç–æ–º –∫—É—Ä—Å–µ –ø–æ–∫–∞ –Ω–µ—Ç –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤")
                    await callback.answer()
                    return

                text = f"üìö –ú–∞—Ç–µ—Ä–∏–∞–ª—ã –∫—É—Ä—Å–∞ {course.title}:\n\n"
                for material in materials:
                    text += f"üìù {material.title}\n"
                    if material.files:
                        for file in material.files:
                            text += f"üìé {file.filename}\n"
                    text += "\n"

                await callback.message.edit_text(text)
                await callback.answer()
        except Exception as e:
            logger.error(f"Error in materials callback handler: {e}")
            await callback.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞")

    async def help_handler(self, message: types.Message):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /help"""
        try:
            help_text = (
                "üîç –°–ø—Ä–∞–≤–∫–∞ –ø–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é –±–æ—Ç–∞:\n\n"
                "1Ô∏è‚É£ /start - –ù–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É —Å –±–æ—Ç–æ–º\n"
                "2Ô∏è‚É£ /courses - –ü–æ–∫–∞–∑–∞—Ç—å —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫—É—Ä—Å–æ–≤\n"
                "3Ô∏è‚É£ /ask - –ó–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å –ø–æ –º–∞—Ç–µ—Ä–∏–∞–ª–∞–º –∫—É—Ä—Å–∞\n"
                "4Ô∏è‚É£ /help - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ\n\n"
                "–ö–∞–∫ –∑–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å:\n"
                "1. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /ask\n"
                "2. –í—ã–±–µ—Ä–∏—Ç–µ –∫—É—Ä—Å –∏–∑ —Å–ø–∏—Å–∫–∞\n"
                "3. –í–≤–µ–¥–∏—Ç–µ –≤–∞—à –≤–æ–ø—Ä–æ—Å\n"
                "4. –ü–æ–ª—É—á–∏—Ç–µ –æ—Ç–≤–µ—Ç —Å —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π\n"
                "5. –ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ –∑–∞–¥–∞–≤–∞—Ç—å –≤–æ–ø—Ä–æ—Å—ã"
            )
            await message.reply(help_text)
        except Exception as e:
            logger.error(f"Error in help handler: {e}", exc_info=True)
            await message.reply("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∫–æ–º–∞–Ω–¥—ã")

    async def process_question(self, message: types.Message):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤–æ–ø—Ä–æ—Å–æ–≤ –ø–æ—Å–ª–µ –≤—ã–±–æ—Ä–∞ –∫—É—Ä—Å–∞"""
        try:
            user_id = message.from_user.id
            user_state = self.user_states.get(user_id)

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –æ–∂–∏–¥–∞–µ–º –ª–∏ –º—ã –≤–æ–ø—Ä–æ—Å –æ—Ç —ç—Ç–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            if not user_state or not user_state.get('waiting_for_question'):
                return

            course_id = user_state['course_id']
            question = message.text

            # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å –∫–Ω–æ–ø–∫–æ–π –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
            keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="‚úÖ –ó–∞–≤–µ—Ä—à–∏—Ç—å –¥–∏–∞–ª–æ–≥", callback_data="end_dialog")]
            ])

            with self.app.app_context():
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –∫—É—Ä—Å–∞
                course = Course.query.get(course_id)
                if not course:
                    await message.reply("‚ùå –ö—É—Ä—Å –Ω–µ –Ω–∞–π–¥–µ–Ω", reply_markup=keyboard)
                    return

                # –ü–æ–∏—Å–∫ –æ—Ç–≤–µ—Ç–∞ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –≤–µ–∫—Ç–æ—Ä–Ω–æ–π –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
                await message.reply("üîç –ò—â—É –æ—Ç–≤–µ—Ç –Ω–∞ –≤–∞—à –≤–æ–ø—Ä–æ—Å...")

                try:
                    answer = answer_question(question, self.vector_db_path)

                    if not answer or "–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —è –Ω–µ –Ω–∞—à–µ–ª –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏" in answer:
                        await message.reply(
                            "‚ùå –ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —è –Ω–µ –Ω–∞—à–µ–ª —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –ø–æ –≤–∞—à–µ–º—É –≤–æ–ø—Ä–æ—Å—É.\n"
                            "üí° –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–µ—Ä–µ—Ñ–æ—Ä–º—É–ª–∏—Ä–æ–≤–∞—Ç—å –≤–æ–ø—Ä–æ—Å –∏–ª–∏ –∑–∞–¥–∞—Ç—å –µ–≥–æ –∏–Ω–∞—á–µ.\n\n"
                            "–í—ã –º–æ–∂–µ—Ç–µ –ø—Ä–æ–¥–æ–ª–∂–∞—Ç—å –∑–∞–¥–∞–≤–∞—Ç—å –≤–æ–ø—Ä–æ—Å—ã –ø–æ —ç—Ç–æ–º—É –∫—É—Ä—Å—É.",
                            reply_markup=keyboard
                        )
                        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è –¥–∏–∞–ª–æ–≥–∞
                        self.user_states[user_id] = {
                            'waiting_for_question': True,
                            'course_id': course_id
                        }
                        return

                    # –§–æ—Ä–º–∏—Ä—É–µ–º –ø–æ–ª–Ω—ã–π –æ—Ç–≤–µ—Ç —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º
                    full_response = (
                        f"üìö <b>–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–∏—Å–∫–∞ –ø–æ –∫—É—Ä—Å—É</b>\n"
                        f"<i>{course.title}</i>\n\n"
                        f"‚ùì <b>–í–∞—à –≤–æ–ø—Ä–æ—Å:</b>\n{question}\n\n"
                        f"üîç <b>–ù–∞–π–¥–µ–Ω–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è:</b>\n{answer}\n\n"
                        "üí° –í—ã –º–æ–∂–µ—Ç–µ –ø—Ä–æ–¥–æ–ª–∂–∞—Ç—å –∑–∞–¥–∞–≤–∞—Ç—å –≤–æ–ø—Ä–æ—Å—ã –ø–æ —ç—Ç–æ–º—É –∫—É—Ä—Å—É\n"
                        "   –∏–ª–∏ –Ω–∞–∂–∞—Ç—å –∫–Ω–æ–ø–∫—É ¬´–ó–∞–≤–µ—Ä—à–∏—Ç—å –¥–∏–∞–ª–æ–≥¬ª –¥–ª—è –≤—ã—Ö–æ–¥–∞"
                    )

                    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç–≤–µ—Ç —Å —Ä–∞–∑–±–∏–µ–Ω–∏–µ–º –Ω–∞ —á–∞—Å—Ç–∏ –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
                    await self.send_split_message(
                        chat_id=message.chat.id,
                        text=full_response,
                        parse_mode="HTML",
                        reply_markup=keyboard
                    )
                    logger.info(f"Answered question for user {message.from_user.id} about course {course_id}")

                    # –û—Å—Ç–∞–≤–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ —Ä–µ–∂–∏–º–µ –æ–∂–∏–¥–∞–Ω–∏—è —Å–ª–µ–¥—É—é—â–µ–≥–æ –≤–æ–ø—Ä–æ—Å–∞
                    self.user_states[user_id] = {
                        'waiting_for_question': True,
                        'course_id': course_id
                    }

                except Exception as e:
                    logger.error(f"Error processing question: {str(e)}", exc_info=True)
                    await message.reply(
                        "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∑–∞–ø—Ä–æ—Å–∞. "
                        "–í—ã –º–æ–∂–µ—Ç–µ –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –∑–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –∑–∞–≤–µ—Ä—à–∏—Ç—å –¥–∏–∞–ª–æ–≥.",
                        reply_markup=keyboard
                    )

        except Exception as e:
            user_id = message.from_user.id
            logger.error(f"Error processing question: {e}", exc_info=True)
            await message.reply(
                "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∞—à–µ–≥–æ –≤–æ–ø—Ä–æ—Å–∞. "
                "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /ask —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ.",
                reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(text="‚úÖ –ó–∞–≤–µ—Ä—à–∏—Ç—å –¥–∏–∞–ª–æ–≥", callback_data="end_dialog")]
                ])
            )
            if user_id:
                self.user_states.pop(user_id, None)

    async def after_question_callback_handler(self, callback: types.CallbackQuery):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–µ–π—Å—Ç–≤–∏–π –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –æ—Ç–≤–µ—Ç–∞ –Ω–∞ –≤–æ–ø—Ä–æ—Å"""
        try:
            action = callback.data
            user_id = callback.from_user.id

            if action == "end_dialog":
                # –û—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ –∑–∞–≤–µ—Ä—à–∞–µ–º –¥–∏–∞–ª–æ–≥
                if user_id in self.user_states:
                    self.user_states.pop(user_id)
                await callback.message.edit_text(
                    "‚úÖ –î–∏–∞–ª–æ–≥ –∑–∞–≤–µ—Ä—à–µ–Ω.\n"
                    "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /ask —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –Ω–æ–≤—ã–π –¥–∏–∞–ª–æ–≥ —Å –≤—ã–±–æ—Ä–æ–º –∫—É—Ä—Å–∞."
                )

            await callback.answer()

        except Exception as e:
            logger.error(f"Error in after question callback handler: {e}")
            await callback.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞")

    async def send_split_message(self, chat_id: int, text: str, parse_mode=None, reply_markup=None):
        """–û—Ç–ø—Ä–∞–≤–∫–∞ –¥–ª–∏–Ω–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è —Å —Ä–∞–∑–±–∏–µ–Ω–∏–µ–º –Ω–∞ —á–∞—Å—Ç–∏"""
        MAX_MESSAGE_LENGTH = 3000

        try:
            if len(text) <= MAX_MESSAGE_LENGTH:
                await self.bot.send_message(
                    chat_id=chat_id,
                    text=text,
                    parse_mode=parse_mode,
                    reply_markup=reply_markup
                )
                return

            parts = []
            while text:
                if len(text) <= MAX_MESSAGE_LENGTH:
                    parts.append(text)
                    break

                split_point = text[:MAX_MESSAGE_LENGTH].rfind('\n')
                if split_point == -1:
                    split_point = text[:MAX_MESSAGE_LENGTH].rfind('. ')
                if split_point == -1:
                    split_point = text[:MAX_MESSAGE_LENGTH].rfind(' ')
                if split_point == -1:
                    split_point = MAX_MESSAGE_LENGTH

                parts.append(text[:split_point])
                text = text[split_point:].lstrip()

            for i, part in enumerate(parts, 1):
                if i == len(parts):  # Last part
                    await self.bot.send_message(
                        chat_id=chat_id,
                        text=part,
                        parse_mode=parse_mode,
                        reply_markup=reply_markup
                    )
                else:
                    await self.bot.send_message(
                        chat_id=chat_id,
                        text=part,
                        parse_mode=parse_mode
                    )
                if i < len(parts):
                    await asyncio.sleep(0.5)

        except Exception as e:
            logger.error(f"Error in send_split_message: {str(e)}")
            await self.bot.send_message(
                chat_id=chat_id,
                text="‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è"
            )

    async def start_polling(self):
        """–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞"""
        try:
            logger.info("Starting bot polling...")
            await self.dp.start_polling(self.bot)
        except Exception as e:
            logger.error(f"Error starting bot: {e}")
            raise

    async def ask_course_callback_handler(self, callback: types.CallbackQuery):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—ã–±–æ—Ä–∞ –∫—É—Ä—Å–∞ –¥–ª—è –≤–æ–ø—Ä–æ—Å–∞"""
        try:
            course_id = int(callback.data.split('_')[2])  # –ò—Å–ø–æ–ª—å–∑—É–µ–º –∏–Ω–¥–µ–∫—Å 2, —Ç–∞–∫ –∫–∞–∫ —Ñ–æ—Ä–º–∞—Ç 'ask_course_ID'
            user_id = callback.from_user.id

            with self.app.app_context():
                course = Course.query.get(course_id)
                if not course:
                    await callback.answer("‚ùå –ö—É—Ä—Å –Ω–µ –Ω–∞–π–¥–µ–Ω")
                    return

                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—ã–±—Ä–∞–Ω–Ω—ã–π –∫—É—Ä—Å –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                self.user_states[user_id] = {
                    'waiting_for_question': True,
                    'course_id': course_id
                }

                await callback.message.edit_text(
                    f"üìù –í—ã –≤—ã–±—Ä–∞–ª–∏ –∫—É—Ä—Å: {course.title}\n\n"
                    "–¢–µ–ø–µ—Ä—å –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –≤–∞—à –≤–æ–ø—Ä–æ—Å –≤ —á–∞—Ç.\n"
                    "–í—ã –º–æ–∂–µ—Ç–µ –∑–∞–¥–∞–≤–∞—Ç—å –≤–æ–ø—Ä–æ—Å—ã –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω–æ, –ø–æ–∫–∞ –Ω–µ –Ω–∞–∂–º–µ—Ç–µ –∫–Ω–æ–ø–∫—É ¬´–ó–∞–≤–µ—Ä—à–∏—Ç—å –¥–∏–∞–ª–æ–≥¬ª"
                )
                await callback.answer()

        except Exception as e:
            logger.error(f"Error in ask course callback handler: {e}")
            await callback.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–±–æ—Ä–µ –∫—É—Ä—Å–∞")